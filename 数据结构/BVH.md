## BVH的构建

## BVH的遍历
给定两棵树，两棵树有可能是同一棵树的复制，节点1和节点2，
2. 从节点1的第一个叶节点出发，节点2也是， 一直循环节点叶2，如果节点叶2，就去取下一个节点2，判断是否相交，然后search down 找到第一组相交的叶节点。
3.如果节点2用完了，就取下一个叶节点1，节点2取root，如果两个root是相同的，节点2就从叶节点1出发。

## BVH树的构建
1. root节点没有子节点直接塞
2. root树的代价，每层的代价为k*V(bnd)每个节点;叶节点为0
3. 因此一棵树添加进父节点，无论在哪，其新增代价都为k(Vnew-Vold),添加在父节点，额外的代价为Vnew,添加进子节点树额外的代价基础另算k2(Vnew2-Vold2)，直接添加在子节点的处的话费Vnew2,这样就可以得到到底是添加在父节点，还是某个子节点树的某个位置，循环到底层，计算处天骄在哪个位置。
4. 然后更新其所有上层的boundingBox.
5. 叶节点变为非叶结点的新增代价为2Anew，很关键。
